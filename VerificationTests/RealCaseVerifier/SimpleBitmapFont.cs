using System;

namespace RealCaseVerifier
{
    public static class SimpleBitmapFont
    {
        // 5x7 Font Data (Columns) for ASCII 32-95 (Space to underscore, covering numbers and uppercase)
        // We will implement a subset for simplicity or a full compact set.
        // For brevity in this environment, I'll implement a procedural generator or a small lookup.
        // Actually, let's just do a manual byte array for common chars.

        private static readonly byte[] FontData = new byte[] {
            // Space
            0x00, 0x00, 0x00, 0x00, 0x00,
            // !
            0x00, 0x00, 0x5F, 0x00, 0x00,
            // "
            0x00, 0x07, 0x00, 0x07, 0x00,
            // #
            0x14, 0x7F, 0x14, 0x7F, 0x14,
            // $
            0x24, 0x2A, 0x7F, 0x2A, 0x12,
            // %
            0x23, 0x13, 0x08, 0x64, 0x62,
            // &
            0x36, 0x49, 0x55, 0x22, 0x50,
            // '
            0x00, 0x05, 0x03, 0x00, 0x00,
            // (
            0x00, 0x1C, 0x22, 0x41, 0x00,
            // )
            0x00, 0x41, 0x22, 0x1C, 0x00,
            // *
            0x14, 0x08, 0x3E, 0x08, 0x14,
            // +
            0x08, 0x08, 0x3E, 0x08, 0x08,
            // ,
            0x00, 0x50, 0x30, 0x00, 0x00,
            // -
            0x08, 0x08, 0x08, 0x08, 0x08,
            // .
            0x00, 0x60, 0x60, 0x00, 0x00,
            // /
            0x20, 0x10, 0x08, 0x04, 0x02,
            // 0
            0x3E, 0x51, 0x49, 0x45, 0x3E,
            // 1
            0x00, 0x42, 0x7F, 0x40, 0x00,
            // 2
            0x42, 0x61, 0x51, 0x49, 0x46,
            // 3
            0x21, 0x41, 0x45, 0x4B, 0x31,
            // 4
            0x18, 0x14, 0x12, 0x7F, 0x10,
            // 5
            0x27, 0x45, 0x45, 0x45, 0x39,
            // 6
            0x3C, 0x4A, 0x49, 0x49, 0x30,
            // 7
            0x01, 0x71, 0x09, 0x05, 0x03,
            // 8
            0x36, 0x49, 0x49, 0x49, 0x36,
            // 9
            0x06, 0x49, 0x49, 0x29, 0x1E,
            // :
            0x00, 0x36, 0x36, 0x00, 0x00,
            // ;
            0x00, 0x56, 0x36, 0x00, 0x00,
            // <
            0x08, 0x14, 0x22, 0x41, 0x00,
            // =
            0x14, 0x14, 0x14, 0x14, 0x14,
            // >
            0x00, 0x41, 0x22, 0x14, 0x08,
            // ?
            0x02, 0x01, 0x51, 0x09, 0x06,
            // @
            0x32, 0x49, 0x79, 0x41, 0x3E,
            // A
            0x7E, 0x11, 0x11, 0x11, 0x7E,
            // B
            0x7F, 0x49, 0x49, 0x49, 0x36,
            // C
            0x3E, 0x41, 0x41, 0x41, 0x22,
            // D
            0x7F, 0x41, 0x41, 0x22, 0x1C,
            // E
            0x7F, 0x49, 0x49, 0x49, 0x41,
            // F
            0x7F, 0x09, 0x09, 0x09, 0x01,
            // G
            0x3E, 0x41, 0x49, 0x49, 0x7A,
            // H
            0x7F, 0x08, 0x08, 0x08, 0x7F,
            // I
            0x00, 0x41, 0x7F, 0x41, 0x00,
            // J
            0x20, 0x40, 0x41, 0x3F, 0x01,
            // K
            0x7F, 0x08, 0x14, 0x22, 0x41,
            // L
            0x7F, 0x40, 0x40, 0x40, 0x40,
            // M
            0x7F, 0x02, 0x0C, 0x02, 0x7F,
            // N
            0x7F, 0x04, 0x08, 0x10, 0x7F,
            // O
            0x3E, 0x41, 0x41, 0x41, 0x3E,
            // P
            0x7F, 0x09, 0x09, 0x09, 0x06,
            // Q
            0x3E, 0x41, 0x51, 0x21, 0x5E,
            // R
            0x7F, 0x09, 0x19, 0x29, 0x46,
            // S
            0x46, 0x49, 0x49, 0x49, 0x31,
            // T
            0x01, 0x01, 0x7F, 0x01, 0x01,
            // U
            0x3F, 0x40, 0x40, 0x40, 0x3F,
            // V
            0x1F, 0x20, 0x40, 0x20, 0x1F,
            // W
            0x3F, 0x40, 0x38, 0x40, 0x3F,
            // X
            0x63, 0x14, 0x08, 0x14, 0x63,
            // Y
            0x07, 0x08, 0x70, 0x08, 0x07,
            // Z
            0x61, 0x51, 0x49, 0x45, 0x43
        };

        public static void DrawString(byte[] pixels, int w, int h, string text, int x, int y, byte r, byte g, byte b)
        {
            int cursorX = x;
            foreach (char c in text)
            {
                if (cursorX + 5 >= w) break;
                DrawChar(pixels, w, h, c, cursorX, y, r, g, b);
                cursorX += 6; // 5 + 1 spacing
            }
        }

        private static void DrawChar(byte[] pixels, int w, int h, char c, int x, int y, byte r, byte g, byte b)
        {
            int index = (char.ToUpper(c) - 32) * 5;
            if (index < 0 || index >= FontData.Length) index = 0; // Space as fallback

            for (int col = 0; col < 5; col++)
            {
                byte colData = FontData[index + col];
                for (int row = 0; row < 7; row++)
                {
                    if (((colData >> row) & 1) == 1)
                    {
                        int px = x + col;
                        int py = y + row;
                        if (px >= 0 && px < w && py >= 0 && py < h)
                        {
                            int idx = (py * w + px) * 4;
                            pixels[idx] = r;
                            pixels[idx + 1] = g;
                            pixels[idx + 2] = b;
                            pixels[idx + 3] = 255;
                        }
                    }
                }
            }
        }
    }
}
